#!/bin/bash

set -o errexit
set -o nounset
set -o pipefail

DEBUG=${DEBUG:-}

[ -n "${DEBUG}" ] && set -o xtrace

IMAGE_TOPDIR="/var/cache/kata-containers"
readonly SCRIPTNAME="$0"

readonly DRACUT_ROOTFS=`mktemp --directory -t kata-dracut-rootfs-XXXXXX`
readonly DRACUT_IMAGES=`mktemp --directory -t kata-dracut-images-XXXXXX`
trap exit_handler EXIT

# Parse distro from /etc/os-release file and remove any quotation marks
DISTRO=$(grep '^ID=' /etc/os-release | awk '{print $2}' FS='=')
readonly DISTRO=${DISTRO//\"}

# Supported runtime classes
# NOTE: the kata runtime class must be the first
readonly RUNTIME_CLASSES=( \
  "kata" \
  "kata-cc" \
  "kata-nvidia-gpu" \
  "kata-nvidia-gpu-cc" \
)

DEFAULT_KATA_ARG_DIR="/tmp/kata-containers"
HOST_KERNEL_PATH=""
KATA_LIBEXEC_DIR="/usr/libexec/kata-containers"

ARG_AGENT_DIR_PREFIX=""
ARG_AGENT_POLICY="${KATA_LIBEXEC_DIR}/osbuilder/kata-opa/restricted-policy.rego"
ARG_EXIT_IF_IMAGES_INSTALLED=""
ARG_GENERATE_IMAGE=""
ARG_GUEST_COMPONENTS_TARBALL="${DEFAULT_KATA_ARG_DIR}/coco-guest-components.tar.xz"
ARG_KVERSION=`uname -r`
ARG_OSBUILDER_DIR="${KATA_LIBEXEC_DIR}/osbuilder"
ARG_PAUSE_IMAGE_TARBALL="${DEFAULT_KATA_ARG_DIR}/pause-bundle.tar.xz"
ARG_REMOVE_INSTALLED_IMAGES=""
ARG_RUNTIME_CLASS=${RUNTIME_CLASSES[0]}

# rpm %check sets this to run the script without overwriting host
# content, and not requiring root
TEST_MODE="${TEST_MODE:-}"


die()
{
    echo "+ PANIC: ${SCRIPTNAME} $*" >&2
    exit 1
}


error()
{
    echo "+ ERROR: ${SCRIPTNAME}: $*" >&2
}


info()
{
    echo "+ INFO: ${SCRIPTNAME}: $*"
}


exit_handler()
{
    rm -rf "${DRACUT_ROOTFS}" "${DRACUT_IMAGES}"
}


usage()
{
    cat <<EOT

Usage: ${SCRIPTNAME} [options]

This script builds the kata appliance initrd and image and adds
stable symlink paths in <IMAGE_TOPDIR>/osbuilder-images.

For the runtime class kata (option: -t "kata", which is default),
the initrd is generated on every boot, so IMAGE_TOPDIR is set to
${IMAGE_TOPDIR}, which is a volatile directory.

For all other runtime classes, the initrds are pre-built, so
IMAGE_TOPDIR is set to /usr/share/kata-containers, which is
a directory persisted across boots.

Options:
  -a DIRNAME    Use the passed directory as the agent_dir prefix.  It's
                mostly useful for pointing to an uninstalled kata-agent.
                Default: ${ARG_AGENT_DIR_PREFIX}

  -c            Check if images were already generated for the current
                kernel, and if so, simply exit

  -e PATH       Pause bundle tarball compressed with xz.
                Default: ${ARG_PAUSE_IMAGE_TARBALL}

  -g PATH       Coco guest components tarball compressed with xz.
                Default: ${ARG_GUEST_COMPONENTS_TARBALL}

  -h            Show this help message

  -i            Also generate media for kata image= option. kata
                image= doesn't work out of the box with Fedora/RHEL
                distro kernels so media is not generated by default.

  -k UNAME_R    Set the default kernel version for the inird. UNAME_R
                must follow the "uname -r" format.
                Default: ${ARG_KVERSION}

  -o DIRNAME    Use the passed directory for osbuilder code. Point
                To a git checkout if you want to use upstream osbuilder.
                Default: ${ARG_OSBUILDER_DIR}

  -p PATH       kata-agent policy
                Default: ${ARG_AGENT_POLICY}

  -t RT_CLASS   Generate initrd/image for the RT_CLASS runtime class.
                Default: ${ARG_RUNTIME_CLASS}
                Options: ${RUNTIME_CLASSES[@]}

  -u            Remove existing images from <IMAGE_TOPDIR>/osbuilder-images,
                before installing new ones.
EOT

    exit $1
}


parse_args()
{
    while getopts "a:ce:g:hik:o:p:t:u" opt
    do
        case $opt in
            a) ARG_AGENT_DIR_PREFIX="${OPTARG}" ;;
            c) ARG_EXIT_IF_IMAGES_INSTALLED=1 ;;
            e) ARG_PAUSE_IMAGE_TARBALL="${OPTARG}" ;;
            g) ARG_GUEST_COMPONENTS_TARBALL="${OPTARG}" ;;
            h) usage 0 ;;
            i) ARG_GENERATE_IMAGE=1 ;;
            k) ARG_KVERSION="${OPTARG}" ;;
            o) ARG_OSBUILDER_DIR="${OPTARG}" ;;
            p) ARG_AGENT_POLICY="${OPTARG}" ;;
            t) ARG_RUNTIME_CLASS="${OPTARG}" ;;
            u) ARG_REMOVE_INSTALLED_IMAGES=1 ;;
            *) usage 1 ;;
        esac
    done
    shift $(($OPTIND - 1))

    if [ -n "$*" ]; then
        error "Unhandled options: '$*'"
        usage 1
    fi

    validate_runtime_class
}


make_sure_provided_runtime_class_is_supported()
{
    for rt in "${RUNTIME_CLASSES[@]}"; do
        [ "$rt" == "${ARG_RUNTIME_CLASS}" ] && return 0
    done
    die "${ARG_RUNTIME_CLASS} is not in the list of supported runtime classes"
}


validate_runtime_class()
{
    make_sure_provided_runtime_class_is_supported

    [ -d "/lib/modules/${ARG_KVERSION}" ] || die "${ARG_KVERSION} not valid. -k must be provided"

    # Except for the kata runtime class, the initrds for all other runtime
    # classes are pre-built
    if [ "${ARG_RUNTIME_CLASS}" != "${RUNTIME_CLASSES[0]}" ] ; then
        # /usr is persisted across boots and so are the pre-built initrds
        IMAGE_TOPDIR="/usr/share/kata-containers"

        # kata binaries shipped in the initrd also must be pre-built
        [ -z "${ARG_AGENT_DIR_PREFIX}" ] && die "ARG_AGENT_DIR_PREFIX empty. -a must be provided"
        [ -e "${ARG_PAUSE_IMAGE_TARBALL}" ] || die "ARG_PAUSE_IMAGE_TARBALL invalid. -e must be provided"
        [ -e "${ARG_GUEST_COMPONENTS_TARBALL}" ] || die "ARG_GUEST_COMPONENTS_TARBALL invalid. -g must be provided"
    fi
}


set_HOST_KERNEL_PATH()
{
    local modpath="/lib/modules/${ARG_KVERSION}"
    [ ! -e "$modpath" ] && die "version=${ARG_KVERSION} path=$modpath does not exist"

    local vmname
    for vmname in vmlinuz vmlinux; do
        local trypath="$modpath/$vmname"
        if [ -e "$trypath" ] ; then
            readonly HOST_KERNEL_PATH="$trypath"
            return 0
        fi
    done

    die "Didn't find vmlinu* path in $modpath"
}


exit_if_osbuilder_images_already_installed()
{
    # For the kata runtime class, the kernel symlink points to the
    # host kernel. For the the other runtime classes, it points
    # to a kernel copy.
    if [ "$ARG_RUNTIME_CLASS" != "${RUNTIME_CLASSES[0]}" ] ; then
        local linked_kernel=$(readlink -n "${KERNEL_SYMLINK}" || :)
        if [ "${HOST_KERNEL_PATH}" != "${linked_kernel}" ] ; then
            return 0
        fi
    else
        if [ ! -e ${KERNEL_SYMLINK} ]; then
            return 0
        fi
    fi

    # Check initrd
    if [ ! -e ${INITRD_SYMLINK} ]; then
        return 0
    fi

    # Check image
    if [ -n "${ARG_GENERATE_IMAGE}" ] && [ ! -e ${IMAGE_SYMLINK} ]; then
        return 0
    fi

    info "Nothing to do. The OSBUILDER images are already installed"
    info "Exiting."
    exit 0
}


generate_modules_load_conf()
{
    # Write the modules-load file from all driver .ko.* files in the initrd
    local loadfile="${DRACUT_ROOTFS}/etc/modules-load.d/kata-modules.conf"
    mkdir -p $(dirname $loadfile)

    local modpath
    for modpath in `find ${DRACUT_ROOTFS} -path \*lib/modules/\*\.ko\*`; do
        local name=$(echo $(basename ${modpath}) | cut -d '.' -f 1)
        echo "${name}" >> $loadfile
    done
}


generate_and_extract_dracut_initrd()
{
    local dracut_conf_dir="./dracut/dracut.conf.d"
    local dracut_conf="./dracut/dracut-${ARG_RUNTIME_CLASS}.conf"
    local dracut_verbose=""
    local tmp_initrd=`mktemp --tmpdir=${DRACUT_IMAGES}`
    unlink "$tmp_initrd"

    [ ! -f ${dracut_conf} ] && dracut_conf="/dev/null"
    [ -n "$DEBUG" ] && dracut_verbose="-vvv"

    # Generate initrd using dracut
    # --confdir : directory with the drop-in configurantions for dracut,
    #             mostly provided by kata upstream. These files will be
    #             loaded for all runtime classes.
    # --conf    : dracut configurations specific for the runtime class.
    #             If the file does not exist, /dev/null is provided.
    info "Building dracut initrd"
    dracut ${dracut_verbose} \
        --confdir "${dracut_conf_dir}" \
        --no-compress \
        --conf ${dracut_conf} \
        ${tmp_initrd} ${ARG_KVERSION}

    # Extract the generated rootfs
    info "Extracting dracut initrd rootfs"
    cat ${tmp_initrd} | \
        cpio --extract --preserve-modification-time --make-directories --directory=${DRACUT_ROOTFS}
}


install_trusted_ca_bundle_to_rootfs() {
    local extracted_dir="${DRACUT_ROOTFS}/etc/pki/ca-trust/extracted"

    info "Install trusted tls-ca-bundle.pem"

    mkdir -p "${extracted_dir}"
    update-ca-trust extract -o "${extracted_dir}"

    for cert_dir in "${DRACUT_ROOTFS}/etc/ssl" "${DRACUT_ROOTFS}/etc/pki/tls"; do
        mkdir -p ${cert_dir}
        ln -snf "${extracted_dir}/pem/tls-ca-bundle.pem" "${cert_dir}/cert.pem"
    done
}


make_kata_adjustments_to_dracut_rootfs()
{
    local agent_dir="${ARG_AGENT_DIR_PREFIX}${KATA_LIBEXEC_DIR}/agent"
    local agent_source_bin="${agent_dir}/usr/bin/kata-agent"
    local osbuilder_version="${DISTRO}-${ARG_RUNTIME_CLASS}-osbuilder-version-unknown"

    info "Copying agent directory tree into place"
    \cp -ar ${agent_dir}/* ${DRACUT_ROOTFS}

    info "Calling osbuilder rootfs.sh on extracted rootfs"

    # Make kata specific adjustments
    case ${ARG_RUNTIME_CLASS} in
        "kata")
            AGENT_SOURCE_BIN="${agent_source_bin}" \
                ./rootfs-builder/rootfs.sh \
                -o ${osbuilder_version} \
                -r ${DRACUT_ROOTFS}
            ;;
        "kata-cc")
            AGENT_SOURCE_BIN="${agent_source_bin}" \
            AGENT_POLICY="yes" \
            AGENT_POLICY_FILE="${ARG_AGENT_POLICY}" \
            COCO_GUEST_COMPONENTS_TARBALL="${ARG_GUEST_COMPONENTS_TARBALL}" \
            PAUSE_IMAGE_TARBALL="${ARG_PAUSE_IMAGE_TARBALL}" \
            CONFIDENTIAL_GUEST="yes" \
                ${ARG_OSBUILDER_DIR}/rootfs-builder/rootfs.sh \
                -o ${osbuilder_version} \
                -r ${DRACUT_ROOTFS}

            # Copy dynamic libraries
            ldd ${DRACUT_ROOTFS}/usr/local/bin/api-server-rest | perl -lne 'print $1 if /=>\s+\/lib64\/(\S+)/o' | xargs -i rsync -aL /lib64/{} ${DRACUT_ROOTFS}/lib64/
            ldd ${DRACUT_ROOTFS}/usr/local/bin/attestation-agent | perl -lne 'print $1 if /=>\s+\/lib64\/(\S+)/o' | xargs -i rsync -aL /lib64/{} ${DRACUT_ROOTFS}/lib64/
            ldd ${DRACUT_ROOTFS}/usr/local/bin/confidential-data-hub | perl -lne 'print $1 if /=>\s+\/lib64\/(\S+)/o' | xargs -i rsync -aL /lib64/{} ${DRACUT_ROOTFS}/lib64/
            ldd ${DRACUT_ROOTFS}/usr/bin/kata-agent | perl -lne 'print $1 if /=>\s+\/lib64\/(\S+)/o' | xargs -i rsync -aL /lib64/{} ${DRACUT_ROOTFS}/lib64/

            info "Copy the systemd-remount-fs.service"
            cp /usr/lib/systemd/system/systemd-remount-fs.service ${DRACUT_ROOTFS}/usr/lib/systemd/system/
            cp /usr/lib/systemd/systemd-remount-fs ${DRACUT_ROOTFS}/usr/lib/systemd/

            # TDX requires configfs-tsm to access the attestation report
            systemctl add-wants --root=${DRACUT_ROOTFS} sysinit.target sys-kernel-config.mount

            install_trusted_ca_bundle_to_rootfs
            ;;

        "kata-nvidia-gpu" | "kata-nvidia-gpu-cc")
            # systemd-nvidia-cdi
            cp ${ARG_OSBUILDER_DIR}/systemd/system/nvidia-cdi.service ${DRACUT_ROOTFS}/usr/lib/systemd/system/
            cp ${ARG_OSBUILDER_DIR}/systemd/systemd-nvidia-cdi.sh ${DRACUT_ROOTFS}/usr/lib/systemd/
            systemctl add-wants --root=${DRACUT_ROOTFS} multi-user.target nvidia-cdi.service

            if [ "${ARG_RUNTIME_CLASS}" == "kata-nvidia-gpu" ]; then
                # Comment out the command "nvida-smi conf-compute -srs 1" as this is not CoCo.
                sed -i '/^nvidia-smi conf-compute -srs 1/s/^/#&/' ${DRACUT_ROOTFS}/usr/lib/systemd/systemd-nvidia-cdi.sh

                AGENT_SOURCE_BIN="${agent_source_bin}" \
                AGENT_POLICY="yes" \
                AGENT_POLICY_FILE="${ARG_AGENT_POLICY}" \
                COCO_GUEST_COMPONENTS_TARBALL="${ARG_GUEST_COMPONENTS_TARBALL}" \
                PAUSE_IMAGE_TARBALL="${ARG_PAUSE_IMAGE_TARBALL}" \
                    ${ARG_OSBUILDER_DIR}/rootfs-builder/rootfs.sh \
                    -o ${osbuilder_version} \
                    -r ${DRACUT_ROOTFS}
            else
                AGENT_SOURCE_BIN="${agent_source_bin}" \
                AGENT_POLICY="yes" \
                AGENT_POLICY_FILE="${ARG_AGENT_POLICY}" \
                COCO_GUEST_COMPONENTS_TARBALL="${ARG_GUEST_COMPONENTS_TARBALL}" \
                PAUSE_IMAGE_TARBALL="${ARG_PAUSE_IMAGE_TARBALL}" \
                CONFIDENTIAL_GUEST="yes" \
                    ${ARG_OSBUILDER_DIR}/rootfs-builder/rootfs.sh \
                    -o ${osbuilder_version} \
                    -r ${DRACUT_ROOTFS}

                # TDX requires configfs-tsm to access the attestation report
                systemctl add-wants --root=${DRACUT_ROOTFS} sysinit.target sys-kernel-config.mount
            fi

            # Copy dynamic libraries
            ldd ${DRACUT_ROOTFS}/usr/local/bin/api-server-rest | perl -lne 'print $1 if /=>\s+\/lib64\/(\S+)/o' | xargs -i rsync -aL /lib64/{} ${DRACUT_ROOTFS}/lib64/
            ldd ${DRACUT_ROOTFS}/usr/local/bin/attestation-agent | perl -lne 'print $1 if /=>\s+\/lib64\/(\S+)/o' | xargs -i rsync -aL /lib64/{} ${DRACUT_ROOTFS}/lib64/
            ldd ${DRACUT_ROOTFS}/usr/local/bin/confidential-data-hub | perl -lne 'print $1 if /=>\s+\/lib64\/(\S+)/o' | xargs -i rsync -aL /lib64/{} ${DRACUT_ROOTFS}/lib64/
            ldd ${DRACUT_ROOTFS}/usr/bin/kata-agent | perl -lne 'print $1 if /=>\s+\/lib64\/(\S+)/o' | xargs -i rsync -aL /lib64/{} ${DRACUT_ROOTFS}/lib64/

            info "Copy the systemd-remount-fs.service"
            cp /usr/lib/systemd/system/systemd-remount-fs.service ${DRACUT_ROOTFS}/usr/lib/systemd/system/
            cp /usr/lib/systemd/systemd-remount-fs ${DRACUT_ROOTFS}/usr/lib/systemd/

            # blacklist nouveau
            mkdir -p ${DRACUT_ROOTFS}/etc/modprobe.d/
            echo "blacklist nouveau" > ${DRACUT_ROOTFS}/etc/modprobe.d/blacklist_nouveau.conf

            install_trusted_ca_bundle_to_rootfs
            ;;

        *)
            die "Runtime class not supported \"${ARG_RUNTIME_CLASS}\""
            ;;
    esac
}


generate_rootfs()
{
    # To generate the rootfs, we build an initrd with dracut, extract
    # the initrd content, and then discard the initrd. We then rebuild
    # the initrd using the osbuilder native scripts.
    #
    # This is a bit wasteful, but it's the easiest way to work around
    # obuilder script inflexibility for now, which expect that some rootfs.sh
    # code is called on a fully populated distro root.

    generate_and_extract_dracut_initrd

    # Using the busybox dracut module sets /sbin/init -> busybox
    # We don't want that. Reset it to systemd
    ln -sf ../lib/systemd/systemd ${DRACUT_ROOTFS}/usr/sbin/init

    # override the auto-cpu-onlining udev rule
    # Workarounds KATA-747
    echo 'SUBSYSTEM=="cpu", ACTION=="add", TEST=="online", ATTR{online}=="0", ATTR{online}="0"' > ${DRACUT_ROOTFS}/usr/lib/udev/rules.d/99-rm-cpu-onlining.rules

    # dracut doesn't have a native module for chrony
    # Fixes KATA-4007
    info "Copying chrony files"
    rsync -a /usr/sbin/chronyd ${DRACUT_ROOTFS}/usr/sbin/
    ldd /usr/sbin/chronyd | perl -lne 'print $1 if /=>\s+\/lib64\/(\S+)/o' | xargs -i rsync -aL /lib64/{} ${DRACUT_ROOTFS}/lib64/
    rsync -a /etc/sysconfig/chronyd ${DRACUT_ROOTFS}/etc/sysconfig/
    rsync -a /usr/lib/systemd/system/chronyd.service ${DRACUT_ROOTFS}/usr/lib/systemd/system/
    echo "WantedBy=kata-containers.target" >> ${DRACUT_ROOTFS}/usr/lib/systemd/system/chronyd.service
    echo "chrony:x:992:" >> ${DRACUT_ROOTFS}/etc/group
    echo "chrony:x:994:992:chrony:/:/usr/sbin/nologin" >> ${DRACUT_ROOTFS}/etc/passwd

    make_kata_adjustments_to_dracut_rootfs

    # Generate modules-load.d file
    generate_modules_load_conf

    # Mask initrd.target and default to multi-user.target
    # Temporary workaround for KATA-3944
    systemctl mask --root=${DRACUT_ROOTFS} initrd.target
    systemctl set-default --root=${DRACUT_ROOTFS} multi-user.target
}


install_osbuilder_images()
{
    local artifact_suffix="";
    # Add the nvidia driver version to the artifact name to easily
    # determine the included driver version
    if [[ "${ARG_RUNTIME_CLASS}" == "kata-nvidia-gpu"* ]]; then
        artifact_suffix="-$(modinfo --field version -m nvidia -k ${ARG_KVERSION})"
    fi
    local kernel_dest_path="${ARG_KVERSION}/$(basename ${HOST_KERNEL_PATH})"
    local initrd_dest_path="${ARG_KVERSION}/${ARG_RUNTIME_CLASS}${artifact_suffix}.initrd"
    local image_dest_path="${ARG_KVERSION}/${ARG_RUNTIME_CLASS}${artifact_suffix}.img"

    [ -n "${ARG_REMOVE_INSTALLED_IMAGES}" ] && rm -rf "${INSTALL_DIR}"

    mkdir -p "${INSTALL_DIR}/${ARG_KVERSION}"

    pushd ${INSTALL_DIR} > /dev/null

    # For the kata runtime class, we create a symlink to the host kernel,
    # but we don't make a copy of the kernel.
    #
    # For the other runtime classes, the initrds are pre-built. So, we make
    # a copy of the kernel and also create a symlink to it.
    if [ "${ARG_RUNTIME_CLASS}" == "${RUNTIME_CLASSES[0]}" ] ; then
        ln -sf ${HOST_KERNEL_PATH} ${KERNEL_SYMLINK}
    else
        \cp -Zf ${HOST_KERNEL_PATH} ${kernel_dest_path}
        ln -sf ${kernel_dest_path} ${KERNEL_SYMLINK}
    fi

    # Install initrd
    mv -Z ${GENERATED_INITRD} ${initrd_dest_path}
    ln -sf ${initrd_dest_path} ${INITRD_SYMLINK}

    # Install image
    if [ -n "${ARG_GENERATE_IMAGE}" ]; then
        mv -Z ${GENERATED_IMAGE} ${image_dest_path}
        ln -sf ${image_dest_path} ${IMAGE_SYMLINK}
    else
        rm -f ${IMAGE_SYMLINK} ${image_dest_path}
    fi

    popd > /dev/null
}


main()
{
    parse_args $*

    if [ -z "${TEST_MODE}" ]; then
        [ "$(id -u)" -eq 0 ] || die "$0: must be run as root"
    fi

    set_HOST_KERNEL_PATH
    readonly INSTALL_DIR="${IMAGE_TOPDIR}/osbuilder-images"
    readonly KERNEL_SYMLINK="${INSTALL_DIR}/${ARG_RUNTIME_CLASS}.kernel"
    readonly INITRD_SYMLINK="${INSTALL_DIR}/${ARG_RUNTIME_CLASS}.initrd"
    readonly IMAGE_SYMLINK="${INSTALL_DIR}/${ARG_RUNTIME_CLASS}.img"

    readonly GENERATED_INITRD="${DRACUT_IMAGES}/${ARG_RUNTIME_CLASS}.initrd"
    readonly GENERATED_IMAGE="${DRACUT_IMAGES}/${ARG_RUNTIME_CLASS}.img"

    [ -n "${ARG_EXIT_IF_IMAGES_INSTALLED}" ] && exit_if_osbuilder_images_already_installed

    cd "${ARG_OSBUILDER_DIR}"

    # Generate the rootfs using dracut
    generate_rootfs

    if [ -n "${TEST_MODE}" ]; then
        info "Exiting TEST_MODE successfully"
        return
    fi

    # Build the initrd
    info "Calling osbuilder initrd_builder.sh"
    ./initrd-builder/initrd_builder.sh -o ${GENERATED_INITRD} ${DRACUT_ROOTFS}

    # Build the image
    if [ -n "${ARG_GENERATE_IMAGE}" ]; then
        # Build the FS image
        local nsdax_bin="${KATA_LIBEXEC_DIR}/osbuilder/nsdax"
        info "Calling osbuilder image_builder.sh"
        NSDAX_BIN="${nsdax_bin}" \
            ./image-builder/image_builder.sh \
            -o ${GENERATED_IMAGE} ${DRACUT_ROOTFS}
    fi

    install_osbuilder_images
    info "Finished successfully"
}


main $*
